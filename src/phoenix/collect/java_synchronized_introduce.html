<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>java同步说明文字</title>
  </head>
  <body>
    <p>
      在Java中，synchronized修饰的代码块或方法不会被多个线程并发访问。<br/>
它强制要求线程在进入一个方法之前获得一个锁，在离开方法时释放该锁。<br/>
它保证了在同一时刻只有一个线程能执行被其修饰的方法。<br/>
同步方法遵循happens-before机制，它保证了对象状态的改变在其他线程中都是可见的。<br/>
<br/>
如果定义一个静态方法为同步，则是在类上同步，而不是在对象上同步。<br/>
也即如果一个静态同步方法在执行时，整个类被锁住，对该类中的其他静态方法调用会阻塞。<br/>
1）当一个线程进入了一个实例的同步方法，则其他任何线程都不能进入该实例的任何一个同步方法。<br/>
2）当一个线程进入了一个类的静态同步方法，则其他任何线程都不能进入该类的任何一个静态同步方法。<br/>
<br/>
原子访问保证所有操作作为一个整体一次完成。Java并发包java.util.concurrent.atomic定 义了对单个变量进行原子操作的类。<br/>
所有类都有get和set方法，就像对volatile变量的读写一样。volatile只能用来修饰变量，用volatile修饰的变量可能被异步地修改。<br/>
<br/>
锁还支持wait/notify机制，通过他们之间的condition对象。锁对象相对于隐式锁最大的优点是，他们能从尝试获得锁的状态返回。<br/>
如果锁当前不可用或者在一个超时时间之前，tryLock()方法能够返回。在获得锁之前，如果其他线程发送了一个中断，lockInterruptibly()方法能返回。<br/>
<br/>
通过System.gc()提示虚拟机进行垃圾回收，但是不能强迫其执行。<br/>
<br/>
java.lang.ref包能用来声明软引用（soft reference），弱引用（weak reference）和虚引用（phantom reference）。<br/>
垃圾收集器不会回收强引用。在内存不足时才会回收软引用，所以用它实现缓存可以避免内存不足。<br/>
垃圾收集器将会在下一次垃圾收集时回收弱引用。弱引用能被用来实现特殊的map。java.util.WeakHashMap中的key就是弱引用。<br/>
虚引用会被立即回收。能被用来跟踪对象被垃圾回收的活动。<br/>
    </p>
  </body>
</html>