在Java中，synchronized修饰的代码块或方法不会被多个线程并发访问。
 它强制要求线程在进入一个方法之前获得一个锁，在离开方法时释放该锁。 
 它保证了在同一时刻只有一个线程能执行被其修饰的方法。
 同步方法遵循happens-before机制，它保证了对象状态的改变在其他线程中都是可见的。
 
 如果定义一个静态方法为同步，则是在类上同步，而不是在对象上同步。
 也即如果一个静态同步方法在执行时，整个类被锁住，对该类中的其他静态方法调用会阻塞。
1）当一个线程进入了一个实例的同步方法，则其他任何线程都不能进入该实例的任何一个同步方法。
2）当一个线程进入了一个类的静态同步方法，则其他任何线程都不能进入该类的任何一个静态同步方法。

原子访问保证所有操作作为一个整体一次完成。
Java并发包java.util.concurrent.atomic定 义了对单个变量进行原子操作的类。
所有类都有get和set方法，就像对volatile变量的读写一样。
volatile只能用来修饰变量，用volatile修饰的变量可能被异步地修改。

锁还支持wait/notify机制，通过他们之间的condition对象。
锁对象相对于隐式锁最大的优点是，他们能从尝试获得锁的状态返回。
如果锁当前不可用或者在一个超时时间之前，tryLock()方法能够返回。
在获得锁之前，如果其他线程发送了一个中断，lockInterruptibly()方法能返回。

通过System.gc()提示虚拟机进行垃圾回收，但是不能强迫其执行。

java.lang.ref包能用来声明软引用（soft reference），弱引用（weak reference）和虚引用（phantom reference）。
垃圾收集器不会回收强引用。
在内存不足时才会回收软引用，所以用它实现缓存可以避免内存不足。
垃圾收集器将会在下一次垃圾收集时回收弱引用。弱引用能被用来实现特殊的map。java.util.WeakHashMap中的key就是弱引用。
虚引用会被立即回收。能被用来跟踪对象被垃圾回收的活动。
 