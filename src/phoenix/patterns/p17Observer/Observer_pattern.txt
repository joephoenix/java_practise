观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，
这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。

观察者模式中首先会存在两个对象，一个是观察者对象，另一个就是主题对象，
然而，根据面向接口编程的原则，则自然就有抽象主题角色和抽象观察者角色。
理清楚了观察者模式中涉及的角色后，接下来就要理清他们之间的关联了，要想主题对象状态发生改变时，
能通知到所有观察者角色，则自然主题角色必须所有观察者的引用，这样才能在自己状态改变时，通知到所有观察者。

在观察者模式的结构图有以下角色：
抽象主题角色（Subject）：抽象主题把所有观察者对象的引用保存在一个列表中，并提供增加和删除观察者对象的操作，
抽象主题角色又叫做抽象被观察者角色，一般由抽象类或接口实现。

抽象观察者角色（Observer）：为所有具体观察者定义一个接口，在得到主题通知时更新自己，一般由抽象类或接口实现。

具体主题角色（ConcreteSubject）：实现抽象主题接口，具体主题角色又叫做具体被观察者角色。

具体观察者角色（ConcreteObserver）：实现抽象观察者角色所要求的接口，以便使自身状态与主题的状态相协调。

在下面的情况下可以考虑使用观察者模式：
当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用的情况下。
从方面的这个词中可以想到，观察者模式肯定在AOP（面向方面编程）中有所体现.
当对一个对象的改变需要同时改变其他对象，而又不知道具体有多少对象有待改变的情况下。
当一个对象必须通知其他对象，而又不能假定其他对象是谁的情况下。

观察者模式有以下几个优点：
观察者模式实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层，即观察者。
观察者模式在被观察者和观察者之间建立了一个抽象的耦合，被观察者并不知道任何一个具体的观察者，
只是保存着抽象观察者的列表，每个具体观察者都符合一个抽象观察者的接口。
观察者模式支持广播通信。被观察者会向所有的注册过的观察者发出通知。

观察者也存在以下一些缺点：
如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间。
虽然观察者模式可以随时使观察者知道所观察的对象发送了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎样发生变化的。
如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，在使用观察者模式应特别注意这点。